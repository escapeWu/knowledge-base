---
{"dg-publish":true,"permalink":"/frontend/utils/utils-indexed-db-crud/","created":"2024-01-18T16:39:45.000+08:00","updated":"2024-01-25T15:31:45.937+08:00"}
---


#browser #web-storage #utils #frontend 
> generated by GPT-4 
> test by shancw


 使用示例
```ts

const dbWrapper = new IndexedDBWrapper({ dbName: 'myDatabase', storeName: 'myObjectStore' });

// 插入数据
dbWrapper.insert('E-DAM', 'anystring').then(() => {
    console.log('Data inserted');
}).catch((error: DOMException) => {
    console.error('Insert error:', error);
});

// 查询数据
dbWrapper.query('E-DAM').then((value) => {
    console.log('Data queried:', value);
}).catch((error: DOMException) => {
    console.error('Query error:', error);
});

// 删除数据
dbWrapper.delete('E-DAM').then(() => {
    console.log('Data deleted');
}).catch((error: DOMException) => {
    console.error('Delete error:', error);
});

dbWrapper.getAllKeys().then(res => {
	allKeys.value =res
})
```

demo地址：
[github - vue demo](https://github.com/shancwovo/vue-sandbox/tree/main/src/views/projects/indexedDB)

源码：
```ts
// 浏览器数据库IndexedDB
interface DBConfig {
	dbName: string;
	storeName: string;
	version?: number;
	tag: string;
}

export class IndexedDBWrapper {
	private readonly dbName: string;
	private readonly storeName: string;
	private db: IDBDatabase | null;
	private version: number;
	private tag: string;

	constructor({ dbName, storeName, version, tag }: DBConfig) {
		this.dbName = dbName;
		this.storeName = storeName;
		this.db = null;
		this.version = version ?? 1
		this.tag = `${storeName}-${tag}`
	}

	private open(): Promise<IDBDatabase> {
		return new Promise((resolve, reject) => {
			if (this.db) {
				resolve(this.db);
			} else {
				const request = indexedDB.open(this.dbName, this.version);

				request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
					const db = (event.target as IDBOpenDBRequest).result;
					db.createObjectStore(this.storeName, { keyPath: 'key' });
				};

				request.onsuccess = (event: Event) => {
					this.db = (event.target as IDBOpenDBRequest).result;
					resolve(this.db);
				};

				request.onerror = (event: Event) => {
					reject((event.target as IDBOpenDBRequest).error);
				};
			}
		});
	}

	public async insert(subKey: string, value: string): Promise<void> {
		const key = `${this.tag}-${subKey}`
		const db = await this.open();
		return await new Promise<void>((resolve, reject) => {
			const transaction = db.transaction([this.storeName], 'readwrite');
			const store = transaction.objectStore(this.storeName);
			const request = store.put({key, value});

			request.onsuccess = () => resolve();
			request.onerror = (event: Event) => reject((event.target as IDBRequest).error);
		});
	}

	public async delete(subKey: string): Promise<void> {
		const key = `${this.tag}-${subKey}`
		const db = await this.open();
		return await new Promise<void>((resolve, reject) => {
			const transaction = db.transaction([this.storeName], 'readwrite');
			const store = transaction.objectStore(this.storeName);
			const request = store.delete(key);

			request.onsuccess = () => resolve();
			request.onerror = (event: Event) => reject((event.target as IDBRequest).error);
		});
	}

	public async query(subKey: string): Promise<string | null> {
		const key = `${this.tag}-${subKey}`
		const db = await this.open();
		return await new Promise<string | null>((resolve, reject) => {
			const transaction = db.transaction([this.storeName], 'readonly');
			const store = transaction.objectStore(this.storeName);
			const request = store.get(key);

			request.onsuccess = (event: Event) => {
				const result_1 = (event.target as IDBRequest).result;
				resolve(result_1 ? result_1.value : null);
			};
			request.onerror = (event_1: Event) => reject((event_1.target as IDBRequest).error);
		});
	}

  public async getAllKeys(): Promise<string[]> {
		const db = await this.open();
		return new Promise<string[]>((resolve, reject) => {
			const transaction = db.transaction([this.storeName], 'readonly');
			const store = transaction.objectStore(this.storeName);
			const request = store.getAllKeys();

			request.onsuccess = (event: Event) => {
				const result = (event.target as IDBRequest).result;
				resolve(result ? result : []);
			};
			request.onerror = (event: Event) => reject((event.target as IDBRequest).error);
		});
	}
}

```
